module scopes

imports
  libstratego-lib

signature
  sorts
    Env
    Scope
    Binding

  constructors
    Env : list(Scope) * Int -> Env
    Scope : list(Binding) -> Scope
    Binding: String * Int -> Binding
    
rules
  /**
    new-environment :: Env
    
  */
  
  new-environment = !Env([<new-scope>], 0)
  
  /**
    environment-get-offset :: Env -> Int
  */
  environment-get-offset = ?Env(_, <id>)
  
  /**
    new-scope :: Scope
  */
  new-scope = !Scope([])
  
  
  /**
    push-scope :: Env -> Env
  */
  push-scope : Env(scopes, offset) -> Env([scope | scopes], offset)
    with
      scope := <new-scope>
  
  /**
    pop-scope :: Env -> Env
  */
  pop-scope = Env(Tl, id)
  
  //peek-scope :: Env -> Scope
  peek-scope = ?Env(<Hd>, _)

  /**
    fresh-variable :: Env -> (Env, String)
  */
  fresh-variable = !(<Env(id, inc)>, <environment-get-offset ; offset-to-variable>)
  
  /**
    fresh-variables :: Env -> (Env, [String])
  */
  fresh-variables(|amount): env -> <env-fold-map(?(<fresh-variable>, _))> (env, <copy> (amount, ())) 
  
  
  
  offset-to-variable = !$[_[<id>]]
  
  /**
    store-variable :: (Env, String) -> (Env, String)
  */
  store-variable : (env, var) -> (env', <offset-to-variable> offset)
    with
      Env([Scope(bindings) |ss], offset) := env
    ; binding := Binding(var, offset)
    ; env' := Env([Scope([binding | bindings]) | ss], <inc> offset)
  store-variable(|var) = <store-variable> (<id>, var)
  
  store-variables(|variables) = env-thread-param(store-variables | variables)
  store-variables = env-fold-map(store-variable)
  
  /**
    get-variable :: (Env,String) -> String
  */
  get-variable = ?(<id>, var) ; ?Env(<fetch-elem(get-variable-from-scope(|var))>, _) ; offset-to-variable
  get-variable(|var) = !(<id>, var) ; get-variable

  

  //get-variable-from-scope :: Scope -> Int
  get-variable-from-scope(|var) = ?Scope(<fetch-elem(where(binding-equals(|var)) ; ?Binding(_, <id>))>)
  
  
  //get-variables-in-scope :: Scope -> [Binding]
  get-bindings-in-scope = ?Scope(<id>)
  
  //get-bindings-in-top-scope :: Env -> [Binding]
  get-bindings-in-top-scope = peek-scope ; get-bindings-in-scope
  
  binding-equals(|x) = ?Binding(x', offset) ; <(rm-annotations, rm-annotations) ; eq> (x, x')
  
  binding-to-tuple : Binding(name, offset) -> (name, offset)
  
  /**
    s_i: Env -> (Env, Term)
    thread-env :: Env -> (Env, (Term_i))
  */
  thread-environment(s1) = s1 ; (id, ![<id>])
  thread-environment(s1) = s1 ; !(<id>, [])
  
  thread-environment(s1, s2) = do-threading(s1, thread-environment(s2))
  thread-environment(s1, s2, s3) = do-threading(s1, thread-environment(s2, s3))
  thread-environment(s1, s2, s3, s4) = do-threading(s1, thread-environment(s2, s3, s4))
  thread-environment(s1, s2, s3, s4, s5) = do-threading(s1, thread-environment(s2, s3, s4, s5))
  thread-environment(s1, s2, s3, s4, s5, s6) = do-threading(s1, thread-environment(s2, s3, s4, s5, s6))
  thread-environment(s1, s2, s3, s4, s5, s6, s7) = do-threading(s1, thread-environment(s2, s3, s4, s5, s6, s7))
  thread-environment(s1, s2, s3, s4, s5, s6, s7, s8) = do-threading(s1, thread-environment(s2, s3, s4, s5, s6, s7, s8))
  
  
  do-threading(s, cont) = s ; ?(<cont>, t) ; (id, ![t | <id>])
  do-threading(s, cont) = s ; cont
  
  /**
    do-fold :: ((env, [value]), value) -> (env, [value])
  */
  env-fold(do-fold) = env-fold(do-fold |[]) ; (id, reverse)
  env-fold(do-fold | initial) : (env, values) -> <foldl(flip(do-fold))> (values, (env, initial))
  
  /**
    do-fold :: (env, value) -> (env, value)
  */
  env-fold-map(do-fold) = env-fold(do-env-fold-map(do-fold))
  
  do-env-fold-map(do-fold) : ((env, acc), cur) -> (env', [value | acc])
    with
      (env', value) := <do-fold> (env, cur)
  
  /**
    do-fold :: (env, value) -> (env, [value])
  */
  env-fold-mapconcat(do-fold) =  env-fold(do-env-fold-mapconcat(do-fold))
  
  do-env-fold-mapconcat(do-fold): ((env, acc), cur) -> (env', <conc> (value*, acc))
    with
      (env', value*) := <do-fold; (id, reverse)> (env, cur) 
  
  /**
    s :: (env, param) -> (env, value)
  */
  env-thread-param(s|param): env -> <s> (env, param) 
  
  /**
    s :: (env) -> value
    env-readonly :: Env -> (Env, value)
  */
  env-readonly(s): env -> (env, <s> env)
  