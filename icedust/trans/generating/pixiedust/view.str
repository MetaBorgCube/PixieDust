module generating/pixiedust/view

imports
  signatures/Types-sig
  
  analysis2/path

  api/module-names-api
  api/model-names-api
  api/types-api
  
  lib/scopes

  generating/pixiedust/names
  generating/pixiedust/expression

rules

  modulename-to-view-stmts : (env, x_moduleName) -> result
    with
      entityNames := <modulename-get-entitynames> x_moduleName
    ; viewAttributes := <mapconcat(entityname-get-arrinames-defined ; filter(attributename-has-type(|View())))> entityNames
    ; (env', stmts) := <env-fold-mapconcat(view-attribute-to-component)> (env, viewAttributes)
    ; result := (env', stmts)
      
  view-attribute-to-component : (env, x_attributeName) -> result
    with
      x_entityName := <attributename-get-entityname> x_attributeName
    ; x_entityNameCamel := <component-entity-prop-name> x_entityName
    ; x_componentName := <component-name> (x_entityName, x_attributeName)
    ; x_getter := <getter-name> x_attributeName
    ; x_subscribeDirtyDependsOn := <subscribe-dirty-dependson-method-name>
    ; x_unsubscribeDirtyDependsOn := <unsubscribe-dirty-dependson-method-name>
    ; (env', [
      x_this,
      stmts_subscribeDirtyDependsOn,
      stmts_unsubscribeDirtyDependsOn
    ]) := <thread-environment(
      push-scope,
      env-thread-param(store-variable | This()),
      env-thread-param(attributename-to-subscribe-dependson-stmts(subscribe-dirty-name) | x_attributeName),
      env-thread-param(attributename-to-subscribe-dependson-stmts(unsubscribe-dirty-name) | x_attributeName),
      pop-scope
    )> env
    ; stmts_component := js-stmts |[
        class x_componentName extends PixieDustComponent {
          constructor(props, context) {
            super(props, context);
            this.x_subscribeDirtyDependsOn(props);
          }
          
          componentWillReceiveProps(nextProps) {
            if(this.props.x_entityNameCamel !== nextProps.x_entityNameCamel) {
              this.x_unsubscribeDirtyDependsOn(this.props);
              this.x_subscribeDirtyDependsOn(nextProps);
            }
          }
          
          componentWillUnmount(){
            super.componentWillUnmount();
            this.x_unsubscribeDirtyDependsOn(this.props);
          }
          
          x_subscribeDirtyDependsOn(props){
            var x_this = props.x_entityNameCamel;
            stmts_subscribeDirtyDependsOn
          }
          
          x_unsubscribeDirtyDependsOn(props) {
            var x_this = props.x_entityNameCamel;
            stmts_unsubscribeDirtyDependsOn
          }
          
          render() {
            return this.props.x_entityNameCamel.x_getter();
          }
        }
      ]|
    ; result := (env', stmts_component)
      
      
  attributename-to-subscribe-dependson-stmts(subscribe-dirty-method-name): (env, x_attributeName) -> result
    with
      dependencies := <attributename-get-dependencies> x_attributeName
    ; result := <env-fold-mapconcat(pathexpr-to-subscribe-stmts(subscribe-dirty-method-name))> (env, dependencies) 
 
  /**
    subscribe-dirty-method-name :: String -> String
  */
  pathexpr-to-subscribe-stmts(subscribe-dirty-method-name) : (env, pathexpr) -> result
    with
      (env', (x_attributeName, exp_e, stmts_e)) := <pathexpr-to-js-stmts> (env, pathexpr)
    ; x_getter := <getter-name> x_attributeName
    ; x_subscribeDirtyMethodName := <subscribe-dirty-method-name> x_attributeName
    ; switch <pathexpr-shorten-safe ; get-multiplicity> pathexpr
        case upper-one:
          env'' := env'
        ; stmts_invalidate := js-stmts |[
            if(exp_e !== null) {
              exp_e.x_subscribeDirtyMethodName(this.scheduleRender);
            }
          ]|
        case upper-many:
          (env'', [x_loop]) := <fresh-variables(|1)> env'  
        ; stmts_invalidate := js-stmts |[
            for(var x_loop = 0 ; x_loop < exp_e.length ; x_loop++) {
              exp_e[x_loop].x_subscribeDirtyMethodName(this.scheduleRender);
            }
          ]|
      end
    ; stmts_result := js-stmts |[
      stmts_e
      stmts_invalidate
    ]|
    ; result := (env'', stmts_result)
  
  
  attributename-get-dependencies = name-get-dependson-paths ; filter(path-pathexpr ; not(dependencypath-is-view))
  dependencypath-is-view = where(pathexpr-last ; name-get-type ; ?View())
  
  