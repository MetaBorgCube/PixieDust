module generating/pixiedust/model

imports
  api/model-names-api
  
  analysis2/path
  
  generating/pixiedust/names
  generating/pixiedust/expression
  
  api/types-names-api
  api/types-api
  
  lib/scopes
  lib/lists-tuples

rules
  entityname-to-js-stmts: (env, x_entityname) -> <!(env', <id>)> js-stmt* |[
    class x_entityname {
      constructor(){
        stmts_subscription
        stmts_init
      }
      methods_attributes
    }
  ]|
    with
      attributenames := <entityname-get-arrinames-defined> x_entityname
    ; (env', [
        stmts_subscription,
        stmts_init,
        methods_attributes
      ]) := <thread-environment(
        env-thread-param(env-fold-mapconcat(init-subscription)|attributenames),
        env-thread-param(env-fold-mapconcat(init-attribute)|attributenames),
        env-thread-param(env-fold-mapconcat(attributename-to-js-methods)|attributenames)
      )> env
      
  
rules // Dirty flagging

  flag-dirty-method : (env, x_attributename) -> (env', method)
    with
      x_methodName := <flag-dirty-name> x_attributename
    ; x_dirtySubscribers := <dirty-subscribers-name> x_attributename
    ; exp_callDirtySubscriber := <exp-call-dirty-subscriber>
    ; (env', [
      stmts_clearCache,
      stmts_flowsto
    ]) := <thread-environment(
      env-thread-param(flag-dirty-clear-cached-value|x_attributename),
      env-thread-param(env-fold-mapconcat(dataflow-path-to-dirty-flag-stmts)|<name-get-flowsto-paths> x_attributename)
    )> env
    ; method := js-method |[
        x_methodName(){
          stmts_clearCache
          if(this.x_dirtySubscribers !== undefined) {
            this.x_dirtySubscribers.forEach(exp_callDirtySubscriber);
          }
          stmts_flowsto
        }
      ]|
      
  
  flag-dirty-clear-cached-value: (env, x_attributename) -> (env, stmts_clear)
    where
      <name-is-default-derived> x_attributename
    ; x_cache := <cache-value> x_attributename
    ; stmts_clear := js-stmts |[
      this.x_cache = undefined;
    ]|
  
  flag-dirty-clear-cached-value = (id, ![])
  
    
  dataflow-path-to-dirty-flag-stmts : (env, DataflowPath(origin, pathexpr)) -> (env'', stmts)
    with
      x_attributeName           := <pathexpr-last>pathexpr
    ; x_flagDirty               := <flag-dirty-name>x_attributeName
    ; e                         := <pathexpr-shorten-safe> pathexpr
    ; (env', (exp_e, stmts_e))  := <exp-to-js-stmts> (env, e)
    ; stmts_flagDirty := <switch !e
      case This():
        env'' := env'
      ; !js-stmts |[
        exp_e.x_flagDirty();
      ]|
      case get-multiplicity ; upper-one:
        env'' := env'
      ; !js-stmts |[
          if(exp_e !== null) {
            exp_e.x_flagDirty();
          }
        ]|
      case get-multiplicity ; upper-many:
        (env'', x_loop) := <fresh-variable> env'
      ; !js-stmts |[
          for(var x_loop = 0 ; x_loop < exp_e.length ; x_loop++) {
            exp_e[x_loop].x_flagDirty();
          }
        ]|
    end> e
    ; stmts := js-stmts |[
      stmts_e
      stmts_flagDirty
    ]|
  
rules // Normal attribute
  
  attributename-to-js-methods : (env, x_attributename) -> 
    <thread-environment(
        env-thread-param(normal-getter-method| x_attributename),
        env-thread-param(flag-dirty-method| x_attributename),
        env-thread-param(unidirectional-setter-method | x_attributename),
        env-thread-param(setter-method | x_attributename)
    )> env
    where
      <attributename-is-normal> x_attributename
  
  
  attributename-to-js-methods : (env, x_attributename) ->
    <thread-environment(
//        env-thread-param(normal-getter-method|x_attributename),
        env-thread-param(flag-dirty-method| x_attributename),
        env-thread-param(derived-getter-method| x_attributename)
    )> env
    where
      <attributename-is-derivation> x_attributename
  
  attributename-to-js-methods : (env, x_attributename) ->
    <thread-environment(
//        env-thread-param(normal-getter-method|x_attributename),
        env-thread-param(flag-dirty-method| x_attributename),
        env-thread-param(default-getter-method| x_attributename),
        env-thread-param(setter-method | x_attributename)
    )> env
    where
      <attributename-is-default> x_attributename
    
  
rules // Getter  
  normal-getter-method: (env, x_attributename) -> <!(env, <id>)> js-method |[
    x_methodName(){
      return this.x_attributename;
    }
  ]|
    with
      x_methodName := <getter-name> x_attributename
    
  derived-getter-method: (env, x_attributename) -> result
    where
      <is-relationname; relationname-is-right> x_attributename
    with
      x_methodName := <getter-name> x_attributename
    ; x_cacheValue := <cache-value> x_attributename
    ; exp_empty := <exp-empty-attribute> x_attributename
    ; method := js-method |[
      x_methodName() {
        return this.x_cacheValue !== undefined ? this.x_cacheValue : exp_empty;
      }
    ]|
    ; result := (env, method)
    
      
  derived-getter-method: (env, x_attributename) -> result
    with
      e_derived := <attributename-get-expr> x_attributename
    ; x_methodName := <getter-name> x_attributename
    ; x_cacheValue := <cache-value> x_attributename
    ; (env', [
      (exp_derived, stmts_derived)
    ]) := <thread-environment(
      exp-to-js-stmts(|e_derived)
    )> env
    ; method := js-method |[
      x_methodName(){
        if(this.x_cacheValue === undefined) {
          stmts_derived
          this.x_cacheValue = exp_derived;
        }
        return this.x_cacheValue;
      }
    ]|
    ; result := (env', method)
  
  default-getter-method: (env, x_attributename) -> result
    with
      e_default := <attributename-get-expr> x_attributename
    ; x_methodName := <getter-name> x_attributename
    ; x_cacheValue := <cache-value> x_attributename
    ; x_userValue := <user-value> x_attributename
    ; (env', (exp_default, stmts_default)) := <exp-to-js-stmts> (env, e_default)
    ; method := js-method |[
      x_methodName(){
        if(this.x_userValue !== null) {
          return this.x_userValue;
        } else {
          if(this.x_cacheValue === undefined) {
            stmts_default
            this.x_cacheValue = exp_default;      
          }
          return this.x_cacheValue;
        }
      }
    ]|
    ; result := (env', method)
    
rules // Setter

//  normal-setter-method (env, x_attributename) ->
    unidirectional-setter-method: (env, x_attributename) -> result
      where
        <is-relationname> x_attributename
      with
        x_methodName := <unidirectional-setter-name> x_attributename
      ; x_flagDirty := <flag-dirty-name> x_attributename
      ; method := js-method |[
          x_methodName(x_attributename) {
            this.x_attributename = x_attributename;
            this.x_flagDirty();
          }
        ]|
      ; result := (env, method)
    
    //fallback if field does not need a unidirectional setter
    unidirectional-setter-method = Fst
    
    setter-method: (env, x_attributename) -> result
      with
        x_setter := <setter-name> x_attributename
      ; x_flagDirty := <flag-dirty-name> x_attributename
      ; (env', stmts_setterInverse) := <setter-relation-inverse> (env, x_attributename)
      ; method := js-method |[
          x_setter(x_attributename) {
            stmts_setterInverse
            this.x_attributename = x_attributename;
            this.x_flagDirty();
          }
        ]|
      ; result := (env', method)
      
    setter-relation-inverse: (env, x_attributename) -> result
      where
        <is-relationname ; name-get-multiplicity ; upper-one> x_attributename
      with
        x_inverse := <relationname-get-inversename> x_attributename
      ; x_getter := <getter-name> x_attributename
      ; (env', [
        x_previous
      ]) := <fresh-variables(|1)> env
      ; stmts_unsetInverse := <setter-relation-inverse-unset> (x_inverse, x_previous)
      ; stmts_setInverse := <setter-relation-inverse-set> (x_inverse, x_attributename)
      ; stmts := js-stmts |[
        var x_previous = this.x_getter();
        if(x_previous !== null) {
          stmts_unsetInverse
        }
        stmts_setInverse
      ]|
      ; result := (env', stmts)
    
    setter-relation-inverse: (env, x_attributename) -> result
      where
        <is-relationname ; name-get-multiplicity ; upper-many> x_attributename
      with
        x_getter := <getter-name> x_attributename
      ; x_inverse := <relationname-get-inversename> x_attributename
      ; x_unidirectionalSetterInverse := <unidirectional-setter-name> x_inverse
      ; (env', [
        x_this,
        x_previous,
        x_added,
        x_loopAdd,
        x_removed,
        x_loopRemove,
        x_removedElement,
        x_addedElement
      ]) := <fresh-variables(|8)> env
      ; stmts := js-stmts |[
        var x_this = this;
        var x_previous = this.x_getter();
        var x_removed = new Set(x_previous);
        for(var x_loopAdd = 0 ; x_loopAdd < x_previous.length ; x_loopAdd++) {
          x_removed["delete"](x_previous[x_loopAdd]);
        }
        var x_added = new Set(x_attributename);
        for(var x_loopRemove = 0 ; x_loopRemove < x_attributename.length ; x_loopRemove++){
          x_added["delete"](x_previous[x_loopRemove]);
        }
        x_added.forEach(function(x_addedElement){
          x_addedElement.x_unidirectionalSetterInverse(x_this);
        });
        x_removed.forEach(function(x_removedElement){
          x_removedElement.x_unidirectionalSetterInverse(null);
        });
      ]|
      ; result := (env', stmts)
    
    setter-relation-inverse = (id, ![])
    
    setter-relation-inverse-set : (x_attribute, x_ref) -> <do-setter-relation-inverse-set> (x_attribute, m_attribute, x_ref)
      with
        m_attribute := <name-get-multiplicity> x_attribute
    
    do-setter-relation-inverse-set: (x_attribute, m_attribute, x_ref) -> result
      where
        <upper-one> m_attribute
      with
        x_unidirectionalSetter := <unidirectional-setter-name> x_attribute
      ; result := js-stmts |[
          x_ref.x_unidirectionalSetter(this);
        ]|
        
    do-setter-relation-inverse-set: (x_attribute, m_attribute, x_ref) -> result
      where
        <upper-many> m_attribute
      with
        x_unidirectionalSetter := <unidirectional-setter-name> x_attribute
      ; x_getter := <getter-name> x_attribute
      ; result := js-stmts |[
          x_ref.x_unidirectionalSetter(x_ref.x_getter().concat([this]));
        ]|
    
    setter-relation-inverse-unset: (x_attribute, x_ref) -> <do-setter-relation-inverse-unset> (x_attribute, m_attribute, x_ref)
      with
        m_attribute := <name-get-multiplicity> x_attribute 
    
    do-setter-relation-inverse-unset: (x_attribute, m_attribute, x_ref) -> result
      where
        <upper-one> m_attribute
      with
        x_unidirectionalSetter := <unidirectional-setter-name> x_attribute
      ; result := js-stmts |[
          x_ref.x_unidirectionalSetter(null);
        ]|
    
    do-setter-relation-inverse-unset: (x_attribute, m_attribute, x_ref) -> result
      where
        <upper-many> m_attribute
      with
        x_unidirectionalSetter := <unidirectional-setter-name> x_attribute
      ; x_getter := <getter-name> x_attribute
      ; result := js-stmts |[
          x_ref.x_unidirectionalSetter(_.without(x_ref.x_getter(), this));
        ]|
    
rules // Subscribe / Unsubscribe

  subscribe-method: x_attributename -> js-method |[
    x_subscribeDirtyName(x_dirtySubscriber) {
      if(this.x_dirtySubscribers === undefined) {
        this.x_dirtySubscribers = new Set();
      }
      this.x_dirtySubscribers.add(x_dirtySubscriber);
    }
  ]|
    with
      x_subscribeDirtyName := <subscribe-dirty-name> x_attributename
    ; x_dirtySubscriber := <dirty-subscriber-name> x_attributename
    ; x_dirtySubscribers := <dirty-subscribers-name> x_attributename
    
  unsubscribe-method: x_attributename -> js-method |[
    x_subscribeDirtyName(x_dirtySubscriber) {
      if(this.x_dirtySubscribers !== undefined) {
        this.x_dirtySubscribers["delete"](x_dirtySubscriber);
      }
    }
  ]|
    with
      x_subscribeDirtyName := <subscribe-dirty-name> x_attributename
    ; x_dirtySubscriber := <dirty-subscriber-name> x_attributename
    ; x_dirtySubscribers := <dirty-subscribers-name> x_attributename
    
rules // Constructor

  init-subscription: (env, x_attributename) -> (env, js-stmts |[this.x_dirtySubscribers = undefined;]|)
    with
      x_dirtySubscribers := <dirty-subscribers-name> x_attributename

  init-attribute = where((id, attributename-is-default)) ; init-default-attribute
  init-attribute = where((id, attributename-is-derivation)) ; init-derived-attribute
  init-attribute = where((id, attributename-is-normal)) ; init-normal-attribute

  init-normal-attribute = (id, ![<assign-empty-user-value>])
  init-derived-attribute = (id, ![<assign-empty-cache-value>])
  init-default-attribute = (id, ![<assign-empty-user-value>, <assign-empty-cache-value>])
      
  assign-empty-user-value = !(<user-value>, <exp-empty-attribute>) ; ?(x_userValue, exp_empty) ; !js-stmt |[this.x_userValue = exp_empty;]|
  assign-empty-cache-value = cache-value ; ?x_cacheValue ; !js-stmt |[this.x_cacheValue = undefined;]|
  
  
  
  
  
  