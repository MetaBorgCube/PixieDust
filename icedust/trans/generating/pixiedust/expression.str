module generating/pixiedust/expression

imports
  signatures/Expressions-sig
  signatures/Types-sig
  
  js/util
  pp/js/Expression-pp
  
  lib/scopes
  lib/nabl2
  
  analysis2/path
  
  api/model-names-api
  api/expressions-api
  api/types-names-api
  api/functions-names-api
  api/import-names-api
  api/types-api
  
  generating/pixiedust/names
rules
  
  //overload for expressions that have a contextual multiplicity
  exp-to-js-stmts = ?(env, (NoValue(), m)) ; !(env, (<exp-empty-multiplicity> m, []))
  exp-to-js-stmts = (id, ?(<id>, _)) ; exp-to-js-stmts
  
  exp-to-js-stmts(|e) = !(<id>, e) ; exp-to-js-stmts
  
  exp-to-js-stmts = (id, where(is-literal) ; literal-to-js-stmts ; !(<id>, []))
  
  literal-to-js-stmts = ?Int(<js-int>)
  literal-to-js-stmts = ?Float(<id>) ; js-float
  literal-to-js-stmts = ?True() ; js-true
  literal-to-js-stmts = ?False() ; js-false
  literal-to-js-stmts = ?Datetime(<js-string ; ?exp_date>) ; !js-exp |[new Date(exp_date)]|
  literal-to-js-stmts = ?NoValue() ; get-multiplicity ; exp-empty-multiplicity
  literal-to-js-stmts = ?LitString(<id>) ; js-string
  
  exp-to-js-stmts: (env, This()) -> (env, (<env-to-this-expr> env, [])) 
  
  exp-to-js-stmts: (env, e*) -> result
    where
      <is-list> e*
    with
      (env', x_result) := <fresh-variable> env
    ; (env'', stmts_concat) := <env-fold-mapconcat(exp-push-result(|x_result))> (env, e*)
    ; stmts := js-stmts |[
        var x_result = [];
        stmts_concat
      ]|
    ; result := (env'', (<js-var> x_result, stmts))
      
  exp-push-result(|x_result): (env, e) -> (env', stmts)
    with
      (env', (exp_e, stmts_e)) := <exp-to-js-stmts> (env, e)
    ; stmts := js-stmts |[
      stmts_e
      x_result.push(exp_e);
    ]|
  
  
  // Binary expressions
  
  binexp-to-js-stmts(get, merge) : (env, e) -> result
    where
      (e1, e2) := <get> e
    with
      (env', [
      (exp_e1, stmts_e1), 
      (exp_e2, stmts_e2),
      x_merge
    ]) := <thread-environment(exp-to-js-stmts(|e1), exp-to-js-stmts(|e2), fresh-variable)> env
    ; (env'', exp_merge) := <
         (!(env', e1, e2, exp_e1, exp_e2) ; merge)
      <+ (!(e1, e2, exp_e1, exp_e2) ; merge ; !(env', <id>))
      <+ (!(env', exp_e1, exp_e2) ; merge) 
      <+ (!(exp_e1, exp_e2) ; merge ; !(env', <id>))
    > //overload merge
    ; stmts_result := js-stmt* |[
      stmts_e1
      stmts_e2
      var x_merge = exp_merge;
    ]|
    ; result := (env'', (<js-var> x_merge, stmts_result))
  
  get-lhs-rhs = ?(exp_e1, exp_e2)
  get-lhs-rhs = ?(_, exp_e1, exp_e2)        ; !(exp_e1, exp_e2)
  get-lhs-rhs = ?(_, _, exp_e1, exp_e2)     ; !(exp_e1, exp_e2)
  get-lhs-rhs = ?(_, _, _, exp_e1, exp_e2)  ; !(exp_e1, exp_e2)
    
  binexp-null-check(merge|e1, e2) : params -> exp_result
    where
      exp_merge := <merge> params
    with
      (exp_lhs, exp_rhs) := <get-lhs-rhs> params
    ; switch !(<get-multiplicity> e1, <get-multiplicity> e2)
        case (lower-one, lower-one):
          exp_result := exp_merge
        case (lower-one, id):
          exp_result := js-exp |[exp_rhs !== null ? exp_merge : null]|
        case (id, lower-one):
          exp_result := js-exp |[exp_lhs !== null ? exp_merge : null]|
        case (id, id):
          exp_result := js-exp |[exp_lhs !== null && exp_rhs !== null ? exp_merge : null]|
      end
  
  binexp-merge(get, merge) : (env, e) -> result
    where 
      (e1, e2) := <get> e
    with
      (env', [
        (exp_lhs, stmts_lhs),
        (exp_rhs, stmts_rhs)
      ]) := <thread-environment(exp-to-js-stmts(|e1), exp-to-js-stmts(|e2))> env
    ; result := <
       (!(env', (e1, e2, exp_lhs, exp_rhs, stmts_lhs, stmts_rhs)) ; merge)
    <+ (!(env', (exp_lhs, exp_rhs, stmts_lhs, stmts_rhs)) ; merge)
    >
   
  binexp-to-js-stmts-with-null-check(get, merge) = (id, get ; ?(e1,e2)) ; binexp-to-js-stmts(!(e1,e2), binexp-null-check(merge|e1, e2))   
  
  exp-to-js-stmts = get-binexp(binexp-to-js-stmts-with-null-check)
  
  get-binexp(merge) = merge(?Addition(e1, e2)           ; !(e1, e2), js-add) 
  
  get-binexp(merge) = merge(?Subtraction(e1, e2)        ; !(e1 ,e2), merge-subtract)
  merge-subtract: (e1, e2, exp_lhs, exp_rhs) -> js-exp |[
    (exp_lhs.getTime() - exp_rhs.getTime()) / 1000
  ]|
    where
      (Datetime(), Datetime()) := <(get-type2, get-type2)> (e1, e2)
  merge-subtract = js-sub
  
  get-binexp(merge) = merge(?Multiplication(e1, e2)     ; !(e1, e2), js-mul)
  get-binexp(merge) = merge(?Division(e1, e2)           ; !(e1, e2), js-div)
  get-binexp(merge) = merge(?FloorDivision(e1, e2)      ; !(e1, e2), merge-floor-div)
  merge-floor-div : (exp_lhs, exp_rhs) -> js-exp|[
    parseInt(exp_lhs / exp_rhs)
  ]|
  get-binexp(merge) = merge(?Modulo(e1, e2)             ; !(e1, e2), js-modulo)
  
  //comparison operators
  get-binexp(merge) = merge(?LessThan(e1, e2)           ; !(e1, e2), merge-compare(js-lt))
  get-binexp(merge) = merge(?LessThanEqual(e1, e2)      ; !(e1, e2), merge-compare(js-lte))
  get-binexp(merge) = merge(?GreaterThan(e1, e2)        ; !(e1, e2), merge-compare(js-gt))
  get-binexp(merge) = merge(?GreaterThanEqual(e1, e2)   ; !(e1, e2), merge-compare(js-gte))
  get-binexp(merge) = merge(?Equal(e1, e2)              ; !(e1, e2), merge-compare(js-eqq))
  get-binexp(merge) = merge(?Inequal(e1, e2)            ; !(e1, e2), merge-compare(js-neqq))
  
  merge-compare(compare) : (e1, e2, exp_lhs, exp_rhs) -> <compare> (exp_lhs', exp_rhs')
    where
      (Datetime(), Datetime()) := <(get-type2, get-type2)> (e1, e2)
    with
      exp_lhs' := js-exp |[exp_lhs.getTime()]|
    ; exp_rhs' := js-exp |[exp_rhs.getTime()]|
  merge-compare(compare) = compare
  
  //Logical operators
  
  
  exp-to-js-stmts = ?(_, And(e1, e2)) ; binexp-merge(!(e1,e2), merge-and)
  merge-and: (env, (exp_lhs, exp_rhs, stmts_lhs, stmts_rhs)) -> result
    with
      (env', x_result) := <fresh-variable> env
    ; stmts :=
      js-stmt* |[
      var x_result;
      stmts_lhs
      if(exp_lhs === false){
        x_result = false;
      } else {
        stmts_rhs
        x_result = exp_rhs;
      }
    ]|
    ; result := (env', (<js-var> x_result, stmts))
  
  
  exp-to-js-stmts = ?(_, Or(e1, e2)) ; binexp-merge(!(e1,e2), merge-or)
  merge-or: (env, (exp_lhs, exp_rhs, stmts_lhs, stmts_rhs)) -> result
    with
      (env', x_result) := <fresh-variable> env
    ; stmts := js-stmt* |[
      var x_result;
      stmts_lhs
      if(exp_lhs === true){
        x_result = true;
      } else {
        stmts_rhs
        x_result = exp_rhs;
      }
    ]|
    ; result := (env', (<js-var> x_result, stmts))
  
  
  exp-to-js-stmts = ?(_, Difference(e1,e2)) ; binexp-merge(!(e1,e2), merge-difference)
  
  merge-difference: (env, (e_lhs, e_rhs, exp_lhs, exp_rhs, stmts_lhs, stmts_rhs)) -> result
    with
      exp_result := <switch <(get-multiplicity, get-multiplicity)> (e_lhs, e_rhs)
        case (upper-one, upper-one):
          !js-exp |[exp_lhs == exp_rhs ? null : exp_lhs]|
        case (upper-one, upper-many):
          !js-exp |[_.includes(exp_rhs, exp_lhs) ? null : exp_lhs]|
        case (upper-many, upper-one):
          !js-exp |[exp_rhs == null ? exp_lhs : _.without(exp_lhs, exp_rhs)]|
        case (upper-many, upper-many):
          !js-exp |[_.difference(exp_lhs, exp_rhs)]|
      end>
    ; result := (env, (exp_result, <conc> (stmts_lhs, stmts_rhs)))
  
  
  exp-to-js-stmts = ?(_, ChoiceLeft(e1, e2)) ; binexp-merge(!(e1,e2), merge-choiceleft)
  
  merge-choiceleft: (env, (e_lhs, e_rhs, exp_lhs, exp_rhs, stmts_lhs, stmts_rhs)) -> result
    with
      (env', x_result) := <fresh-variable> env
    ; exp_nonempty := <check-nonempty> (<get-multiplicity> e_lhs, exp_lhs)
    ; stmts := js-stmt* |[
      stmts_lhs
      var x_result;
      if(exp_nonempty){
        x_result = exp_lhs;
      } else{
        stmts_rhs
        x_result = exp_rhs;
      }
    ]|
    ; result := (env', (<js-var> x_result, stmts))
  
  exp-to-js-stmts = ?(_, Merge(e1, e2)) ; binexp-merge(!(e1, e2), merge-merge)
  
  merge-merge : (env, (e_lhs, e_rhs, exp_lhs, exp_rhs, stmts_lhs, stmts_rhs)) -> result 
    with
      exp_lhs2 := <exp-to-list> (e_lhs, exp_lhs)
    ; exp_rhs2 := <exp-to-list> (e_rhs, exp_rhs)
    ; exp_result := js-exp |[
      exp_lhs2.concat(exp_rhs2)
    ]| 
    ; result := (env, (exp_result, <conc> (stmts_lhs, stmts_rhs)))
  
  exp-to-list: (e, exp_e) -> exp_result
    with
      switch <get-multiplicity> e
        case lower-one ; upper-one ; <is-literal> e:
          exp_result := js-exp |[[exp_e]]|
        case upper-one:
          exp_empty := <exp-empty-array>
        ; exp_result := js-exp |[exp_e === null ? exp_empty : [exp_e]]|
        case upper-many:
          exp_result := exp_e
      end
  
  // Unary expressions
  
  unexp-to-js-stmts(get, merge) : (env, e) -> result
    where
      e_inner := <get> e
    with
      (env', [
        (exp_inner, stmts_inner),
        x_result
      ]) := <thread-environment(exp-to-js-stmts(|e_inner), fresh-variable)> env
    ; (env'', exp_merge) := <merge ; (?(_,_) <+ !(env', <id>))> (env', e_inner, exp_inner) 
    ; stmts_result := js-stmt* |[
      stmts_inner
      var x_result = exp_merge;
    ]|
    ; exp_result := <js-var> x_result
    ; result := (env'', (exp_result, stmts_result))
  
  unexp-null-check(merge) : params @ (_, e, exp_e) -> exp_result 
    where
      exp_merge := <merge> params
    with  
     switch <get-multiplicity> e
      case lower-one:
        exp_result := exp_merge
      otherwise:
        exp_result := js-exp |[exp_e !== null ? exp_merge : null]|
    end
  
  unexp-to-js-stmts-with-null-check(get, merge) = unexp-to-js-stmts(get, unexp-null-check(merge))
  
  exp-to-js-stmts = get-unexp(unexp-to-js-stmts-with-null-check)
  
  get-unexp(merge) = merge(?Not(<id>), ?(_, _, <js-not>))
  get-unexp(merge) = merge(?Cast(<id>, t), merge-cast(|t))
  
  merge-cast(|t2) : (_, e, exp_e) -> exp_result
    with
      t1 := <get-type2> e
    ; exp_result := <switch !(t1,t2)
      case ?(Float(), Int())        : !js-exp |[parseInt(exp_e)]|
      case ?(Datetime(), String())  : <js-function-call> ("dateToString", [exp_e])
      case ?(View(), String())      : !js-exp |[runtime.renderViewToString(exp_e)]|
      otherwise                     : !exp_e
    end>
  
  exp-to-js-stmts : (env, If(c, t, f)) -> result
    with
      (env', [
        (exp_c, stmts_c),
        (exp_t, stmts_t),
        (exp_f, stmts_f),
        x_result
      ]) := <thread-environment(
        exp-to-js-stmts(|c),
        exp-to-js-stmts(|t),
        exp-to-js-stmts(|f),
        fresh-variable
      )> env
    ; stmts_result := js-stmt* |[
      var x_result;
      stmts_c
      if(exp_c){
        stmts_t
        x_result = exp_t; 
      } else{
        stmts_f
        x_result = exp_f;
      }
    ]|
    ; exp_result := <js-var> x_result
    ; result := (env', (exp_result, stmts_result))
  
  //Functions
  
  exp-to-js-stmts: (env, e @ Function(name, args)) -> result
    where
      params := <functionname-get-params> name
    with
      zippedParams := <zip> (params, args)
    ; (env', [
      (exps_args, stmts_args),
      x_result
    ]) := <thread-environment(
      env-thread-param(env-fold-map(parameter-to-js-stmts) ; (id, unzip ; (id, concat)) | zippedParams),
      fresh-variable,
      push-scope
    )> env
    ; liftZip := <zip3> (<functionname-get-paramnames> name, <map(get-multiplicity)> args, exps_args)
    ; (env'', [stmts_lift]) := <thread-environment(
      env-thread-param(lift-function-parameters(|x_result, name) | liftZip),
      pop-scope
    )> env'
    ; stmts_result := js-stmts |[
      stmts_args
      var x_result = [];
      stmts_lift
    ]|
    ; switch <get-multiplicity> e
      case upper-one:
        exp_result := js-exp |[
          x_result.length === 0 ? null : x_result[0]
        ]|
      case upper-many:
        exp_result := <js-var> x_result
    end
    ; result := (env'', (exp_result, stmts_result))
  
  //primitive functions have no real parameters
  exp-to-js-stmts: (env, Function(name, args)) -> result
    with
      (env', (exps_args, stmts_args)) := <env-fold-map(exp-to-js-stmts) ; (id, unzip ; (id, concat))> (env, args)
    ; exp_result := <js-function-call> (name, exps_args)
    ; result := (env', (exp_result, stmts_args))
  
  
  lift-function-parameters(|x_result, fname): (env, [x | xs]) -> <lift-function-parameter(!(<id>, xs) ; lift-function-parameters(|x_result, fname))> (env, x)
  lift-function-parameters(|x_result, fname): (env, []) -> result
    with
      paramnames := <functionname-get-paramnames> fname
    ; exps_params := <get-variables ; map(js-var)> (env, paramnames)
    ; exp_call := <js-function-call> (fname, exps_params)
    ; switch <functionname-get-multiplicity> fname
      case upper-one:
        stmts_result := js-stmts|[
          if(exp_call !== null){
            x_result.push(exp_call);
          }
        ]|
      case upper-many:
        stmts_result := js-stmts|[
          x_result = x_result.concat(exp_call);
        ]|
    end
    
    ; result := (env, stmts_result)
  
  // continuation :: Env -> (Env, Stmts)
  lift-function-parameter(continuation): (env, (x_paramname, m_e, exp_e)) -> result
    where
      <(paramname-get-multiplicity, id) ; (upper-one, upper-many)> (x_paramname, m_e)
    with
      (env', [
        x_loop,
        x_exp,
        x_param,
        stmts_continuation
      ]) := <thread-environment(
        fresh-variable,
        fresh-variable,
        store-variable(|x_paramname),
        continuation
      )> env
    ; stmts_result := js-stmts|[
        var x_exp = exp_e;
        for(var x_loop = 0 ; x_loop < x_exp.length ; x_loop++) {
          var x_param = x_exp[x_loop];
          stmts_continuation
        }
      ]|
    ; result := (env', stmts_result)
      
  
  // continuation :: Env -> (Env, Stmts)
  lift-function-parameter(continuation): (env, (x_paramname, m_e, exp_e)) -> result
    where
      <(paramname-get-multiplicity, id) ; (upper-many, upper-one)> (x_paramname, m_e)
    with
      (env', [x_param, stmts_continuation]) := 
        <thread-environment(
          store-variable(|x_paramname),
          continuation
        )> env
    ; stmts_result := js-stmts |[
        var x_param = exp_e === null ? [] : [ exp_e ];
        stmts_continuation
      ]|
    ; result := (env', stmts_result)
  
  lift-function-parameter(continuation): (env, (x_paramname, m_e, exp_e)) -> result
    with
      (env', [x_param, stmts_continuation]) := 
        <thread-environment(
          store-variable(|x_paramname),
          continuation
        )> env
    ; stmts_result := js-stmts |[
        var x_param = exp_e;
        if(x_param !== null) {
          stmts_continuation
        }
      ]| 
    ; result := (env', stmts_result)
    
  parameter-to-js-stmts: (env, (param, e)) -> result
    where
      <is-reference-parameter> param
    with
      e_ref := <pathexpr-shorten-safe> e
    ; (env', [
      (exp_ref, stmts_ref)
    , x_result
    ]) := <thread-environment(
      env-thread-param(exp-to-js-stmts | e_ref),
      fresh-variable
    )> env 
    ; x_attributeName := <pathexpr-last> e
    ; x_getter := <getter-name> x_attributeName
    ; x_setter := <setter-name> x_attributeName
    ; x_subscribeDirty := <subscribe-dirty-name> x_attributeName
    ; x_unsubscribeDirty := <unsubscribe-dirty-name> x_attributeName
    ; stmts_result := js-stmts |[
      stmts_ref
      var x_result = {
        getter: exp_ref.x_getter.bind(exp_ref),
        setter: exp_ref.x_setter.bind(exp_ref),
        subscribeDirty: exp_ref.x_subscribeDirty.bind(exp_ref),
        unsubcribeDirty: exp_ref.x_unsubscribeDirty.bind(exp_ref)
      };
    ]|
    ; result := (env', (<js-var> x_result, stmts_result))
  
//  parameter-to-js-stmts: (env, (param, e)) -> result
//    where
//      ActionType(_) := <param-get-type> param
//    with
//      e_ref := <pathexpr-shorten-safe> e
//    ; (env', (exp_ref, stmts_ref)) := <exp-to-js-stmts> (env, e_ref)
//    ; x_attributeName := <pathexpr-last> e
//    ; exp_result := js-exp |[exp_ref.x_attributeName.bind(exp_ref)]|
//    ; result := (env', (exp_result, stmts_ref))
    
  parameter-to-js-stmts: (env, (param, e)) -> <exp-to-js-stmts> (env, e)
    where
      <is-normal-parameter> param
      
  js-function-call: (x_fn, exps_args) -> js-exp |[exp_fn(exps_args)]|
    with
      exp_fn := <functionname-get-reference-exp> x_fn

  exp-to-js-stmts: (env, Filter(e_source, var, e_body)) -> result
    with
      (env', [
        (exp_source, stmts_source),
        x_var,
        (exp_body, stmts_body),
        x_result,
        x_loop
      ]) := <thread-environment(
        exp-to-js-stmts(|e_source),
        push-scope,
        store-variable(|var),
        exp-to-js-stmts(|e_body),
        pop-scope,
        fresh-variable,
        fresh-variable
      )> env
    ; stmts_result := js-stmt* |[
      stmts_source
      var x_result = [];
      for(var x_loop = 0 ; x_loop < exp_source.length ; x_loop++){
        var x_var = exp_source[x_loop];
        stmts_body
        if(exp_body){
          x_result.push(x_var);
        }
      }
    ]|
    ; exp_result := <js-var> x_result
    ; result := (env', (exp_result, stmts_result))
    
  exp-to-js-stmts: (env, OrderBy(e_source, var, e_body)) -> result
    with
      (env', [
        (exp_source, stmts_source),
        x_arg1,
        x_arg2,
        x_var,
        (exp_body, stmts_body),
        x_result
      ]) := <thread-environment(
        exp-to-js-stmts(|e_source),
        fresh-variable,
        fresh-variable,
        push-scope,
        store-variable(|var),
        exp-to-js-stmts(|e_body),
        pop-scope,
        fresh-variable
      )> env
    ; stmts_result := js-stmt* |[
      stmts_source
      var x_result = exp_source.slice().sort(function(x_arg1, x_arg2){
        var x_var = x_arg1;
        stmts_body
        x_arg1 = exp_body;
        x_var = x_arg2;
        stmts_body
        x_arg2 = exp_body;
        return x_arg1 - x_arg2;
      });
    ]|
    ; exp_result := <js-var> x_result
    ; result := (env', (exp_result, stmts_result))
    
  exp-to-js-stmts: (env, Find(e_source, var, e_body)) -> result
    with
      (env', [
        (exp_source, stmts_source),
        x_var,
        (exp_body, stmts_body),
        x_loop,
        x_result
      ]) := <thread-environment(
        exp-to-js-stmts(|e_source),
        push-scope,
        store-variable(|var),
        exp-to-js-stmts(|e_body),
        pop-scope,
        fresh-variable,
        fresh-variable
      )> env
    ; stmts_result := js-stmt* |[
      stmts_source
      var x_result = null;
      for(var x_loop = 0 ; x_loop < exp_source.length && x_result === null ; x_loop++){
        var x_var = exp_source[x_loop];
        stmts_body
        if(exp_body){
          x_result = x_var;
        }
      }
    ]|
    ; exp_result := <js-var> x_result
    ; result := (env', (exp_result, stmts_result))
    
  //References
  
  exp-to-js-stmts: (env, m@MemberAccess(e, field)) -> result
    with
      m_inner := <get-multiplicity> e
    ; x_attributeName := <get-decl(|"Member")> field
    ; m_outer := <name-get-multiplicity> x_attributeName
    ; x_getter := <getter-name> x_attributeName
    ; (env', (exp_e, stmts_e)) := <exp-to-js-stmts> (env, e)
    ; (env'', (exp_access, stmts_access)) := <member-access-to-js-stmts> (env', (x_attributeName, exp_e, x_getter, m_inner, m_outer))
    ; result := (env'', (exp_access, <conc> (stmts_e, stmts_access)))
  
  member-access-to-js-stmts : (env, (x_attributeName, exp_inner, x_getter, m_inner, m_outer)) -> result
    where
      <upper-many> m_inner
    with
      (env' , [ 
        x_result,
        x_innerElem,
        x_loop
      ]) := <fresh-variables(|3)> env
    ; exp_instance := js-exp |[x_innerElem]|
    ; (env'', (exp_ref, stmts_ref)) := <generate-reference-exp> (env', (exp_instance, m_inner, m_outer, x_attributeName))
    ; stmts_result := js-stmts |[
        var x_result = [];
        for(var x_loop = 0 ; x_loop < exp_inner.length ; x_loop++){
          var x_innerElem = exp_inner[x_loop];
          stmts_ref
          x_result = x_result.concat(exp_ref);
        }
      ]|
    ; result := (env'', (<js-var> x_result, stmts_result))

  
  member-access-to-js-stmts : (env, (x_attributeName, exp_inner, x_getter, m_inner, m_outer)) -> result
    where
      <upper-one> m_inner
    with 
      (env', x_result) := <fresh-variable> env
      ; exp_empty := <exp-empty-multiplicity> m_outer
      ; exp_instance := js-exp |[exp_inner]|
      ; (env'', (exp_ref, stmts_ref)) := <generate-reference-exp> (env', (exp_instance, m_inner, m_outer, x_attributeName))             
      ; stmts_result := js-stmts |[
          stmts_ref
          var x_result = exp_inner === null ? exp_empty : exp_ref;
        ]|
      ; result := (env'', (<js-var> x_result, stmts_result))
  

  env-to-this-expr = (get-variable(|This()) ; js-var) <+ js-this 
  
  exp-to-js-stmts = ?(env, Ref(x)) ; !(env, (<get-variable ; js-var> (env, x), []))
  
  exp-to-js-stmts: (env, Ref(field)) -> result 
    with
      x_attributeName := <get-decl(|"Member")> field
    ; m_outer := <name-get-multiplicity> x_attributeName
    ; e_this := <env-to-this-expr> env
    ; result := <generate-reference-exp> (env, (e_this, One(), m_outer, x_attributeName))


  generate-reference-exp: (env, (exp_entity, m_inner, m_outer, x_attributeName)) -> result
    where
      ActionType(_) := <name-get-type> x_attributeName
    with
      exp_result := js-exp |[
        exp_entity.x_attributeName
      ]|
    ; result := (env, (exp_result, []))
      

  generate-reference-exp: (env, (exp_entity, m_inner, m_outer, x_attributeName)) -> result
    where
      View() := <name-get-type> x_attributeName
    with
      x_entityName := <attributename-get-entityname> x_attributeName
      ; x_componentName := <component-name> (x_entityName, x_attributeName)
      ; x_entityProp := <component-entity-prop-name> x_entityName
      ; (env', x_result) := <fresh-variable> env
      ; x_getIdentity := <identity-name ; getter-name>
      ; prop_key* := <generate-key-prop> (exp_entity, m_inner, m_outer) 
      ; switch !m_outer 
        case upper-one:
          env'' := env'
        ; stmts_result := js-stmts |[
          var x_result = React.createElement(x_componentName, {
            x_entityProp: exp_entity,
            prop_key*
          });
          ]|
        case upper-many:
          (env'', [x_loop, x_instance]) := <fresh-variables(|2)> env'
        ; stmts_result := js-stmts |[
          var x_result = [];
          for(var x_loop = 0 ; x_loop < exp_entity.length ; i++) {
            var x_instance = exp_entity[x_loop];
            x_result.push(React.createElement(x_componentName, {
              x_entityProp: x_instance,
              prop_key*
            }));
          }
        ]|
      end
      ; result := (env'', (<js-var> x_result, stmts_result))


  generate-key-prop: (exp_instance, m_inner, m_outer) -> []
    where
      <(upper-one, upper-one)> (m_inner, m_outer)
  
  generate-key-prop: (exp_instance, m_inner, m_outer) -> js-prop* |[
    key: exp_instance.x_getId()
  ]|
    with
      x_getId := <identity-name ; getter-name> 
      
  generate-reference-exp : (env, (exp_entity, m_inner, m_outer, x_attributeName)) -> result
    with
      x_getter := <getter-name> x_attributeName
    ; (env', x_result) := <fresh-variable> env
    ; stmts_result := js-stmts |[
        var x_result = exp_entity !== null ? exp_entity.x_getter() : null;
      ]|
    ; result := (env', (<js-var> x_result, stmts_result))
    
     
  //Helpers
  
  check-nonempty = where((upper-one, ?exp_e)) ; !js-exp |[exp_e !== null]|
  check-nonempty = where((upper-many, ?exp_e)) ; !js-exp |[exp_e.length !== 0]|
  
  exp-fold = env-fold(do-exp-fold)
  
  do-exp-fold : ((env, acc), e) -> result
    with
      (env', exp_e, stmts_e) := <exp-to-js-stmts> (env, e)
    ; result := (env', [(exp_e, stmts_e) | acc])
  
rules // Views
  exp-to-js-stmts: (env, RenderDomElement(name, attributes, children)) -> result
    with
      exp_name := <js-string> name
    ; (env', [
      (prop_attribute*, stmts_attributes),
      (exps_children, stmts_children)
    ]) := <thread-environment(
      env-thread-param(env-fold-map(attribute-to-js-prop) ; (id, unzip ; (id, concat))|attributes),
      env-thread-param(env-fold-map(exp-to-js-stmts) ; (id, unzip ; (id, concat))|children)
    )> env
    ; exp_result := js-exp |[
      React.createElement(exp_name, {prop_attribute*}, exps_children)    
    ]|
    ; result := (env', (exp_result, <conc> (stmts_attributes, stmts_children)))
      
  
  attribute-to-js-prop: (env, DomElementProperty(x_key, value)) -> result
    with
      (env', (exp_value, stmts_value)) := <attribute-value-to-js-exp> (env, value)
    ; prop_value := js-prop |[x_key: exp_value]|
    ; result := (env', (prop_value, stmts_value))
  
  attribute-value-to-js-exp: (env, DomElementPropertyActionCall(e_action, parameters)) -> result
    with
      (env', [
        (exp_action, stmts_action),
        (exps_parameters, stmts_parameters)
      ]) := <thread-environment(
        env-thread-param(exp-to-js-stmts | e_action),
        env-thread-param(env-fold-map(exp-to-js-stmts) ; (id, unzip ; (id, concat)) | parameters)
      )> env
      ; exp_result := js-exp |[
        (function(){
          stmts_action
          exp_action(exps_parameters);
        }).bind(this)
      ]|
    ; result := (env', (exp_result, []))
   
  attribute-value-to-js-exp = (id, ?DomElementPropertyValueExp(<id>)) ; exp-to-js-stmts 
  attribute-value-to-js-exp = (id, ?DomElementPropertyValueMap(<id>)) ; env-fold-map(attribute-to-js-prop) ; (id, (unzip ; (js-object, concat)))
  
rules
  pathexpr-to-js-stmts: (env, pathexpr) -> result
    with
      x_attributeName           := <pathexpr-last>pathexpr
    ; e                         := <pathexpr-shorten-safe> pathexpr
    ; (env', (exp_e, stmts_e)) := <exp-to-js-stmts> (env, e)
    ; result := (env', (x_attributeName, exp_e, stmts_e))
  
rules //constructor
  exp-to-js-stmts: (env, NewInstance(EntityType(x_name), fields)) -> result
    with
      (env', x_instance) := <fresh-variable> env
    ; (env'', stmts_fields) := <env-fold-mapconcat(instance-value-to-js-stmts(|x_instance))> (env', fields)
    ; stmts_result := js-stmts |[
        var x_instance = new x_name();
        stmts_fields
      ]|
    ; result := (env'', (<js-var> x_instance, stmts_result))
    
  
  instance-value-to-js-stmts(|x_instance): (env, InstanceValue(name, value)) -> result
    with
      (env', (exp_value, stmts_value)) := <exp-to-js-stmts> (env, value)
    ; x_setter := <setter-name> name
    ; stmts_result := js-stmts |[
        stmts_value
        x_instance.x_setter(exp_value);
      ]|
    ; result := (env', stmts_result)
  


