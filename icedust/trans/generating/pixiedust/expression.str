module generating/pixiedust/expression

imports
  signatures/Expressions-sig
  signatures/Types-sig
  
  js/util
  pp/js/Expression-pp
  lib/scopes
  
  api/expressions-api
  api/types-names-api
  api/types-api
  
  generating/pixiedust/names
rules
  
  exp-to-js-stmts(|e) = !(<id>, e) ; exp-to-js-stmts  
  
  //Literals
  
  exp-to-js-stmts = (id, where(is-literal) ; literal-to-js-stmts ; !(<id>, []))
  
  literal-to-js-stmts = ?Int(<id>) ; js-int
  literal-to-js-stmts = ?Float(<id>) ; js-float
  literal-to-js-stmts = ?True() ; js-true
  literal-to-js-stmts = ?False() ; js-false
  literal-to-js-stmts = ?Datetime(<js-string ; ?exp_date>) ; !js-exp |[new Date(exp_date)]|
  literal-to-js-stmts = ?NoValue() ; js-null
  literal-to-js-stmts = ?LitString(<id>) ; js-string
  
  exp-to-js-stmts = (id, ?This(); !(<js-this>, []))
  
  // Binary expressions
  
  binexp-to-js-stmts(get, merge) : (env, e) -> result
    where
      (e1, e2) := <get> e
    with
      (env', [
      (exp_e1, stmts_e1), 
      (exp_e2, stmts_e2),
      x_merge
    ]) := <thread-environment(exp-to-js-stmts(|e1), exp-to-js-stmts(|e2), fresh-variable)> env
    ; (env'', exp_merge) := <
         (!(env', e1, e2, exp_e1, exp_e2) ; merge)
      <+ (!(e1, e2, exp_e1, exp_e2) ; merge ; !(env', <id>))
      <+ (!(env', exp_e1, exp_e2) ; merge) 
      <+ (!(exp_e1, exp_e2) ; merge ; !(env', <id>))
    > //overload merge
    ; stmts_result := js-stmt* |[
      stmts_e1
      stmts_e2
      var x_merge = exp_merge;
    ]|
    ; result := (env'', (<js-var> x_merge, stmts_result))
  
  get-lhs-rhs = ?(exp_e1, exp_e2)
  get-lhs-rhs = ?(_, exp_e1, exp_e2)        ; !(exp_e1, exp_e2)
  get-lhs-rhs = ?(_, _, exp_e1, exp_e2)     ; !(exp_e1, exp_e2)
  get-lhs-rhs = ?(_, _, _, exp_e1, exp_e2)  ; !(exp_e1, exp_e2)
    
  binexp-null-check(merge|e1, e2) : params -> exp_result
    where
      exp_merge := <merge> params
    with
      (exp_lhs, exp_rhs) := <get-lhs-rhs> params
    ; switch !(<get-multiplicity> e1, <get-multiplicity> e2)
        case (lower-one, lower-one):
          exp_result := exp_merge
        case (lower-one, id):
          exp_result := js-exp |[exp_rhs !== null ? exp_merge : null]|
        case (id, lower-one):
          exp_result := js-exp |[exp_lhs !== null ? exp_merge : null]|
        case (id, id):
          exp_result := js-exp |[exp_lhs !== null && exp_rhs !== null ? exp_merge : null]|
      end
  
  binexp-merge(get, merge) : (env, e) -> result
    where 
      (e1, e2) := <get> e
    with
      (env', [
        (exp_lhs, stmts_lhs),
        (exp_rhs, stmts_rhs)
      ]) := <thread-environment(exp-to-js-stmts(|e1), exp-to-js-stmts(|e2))> env
    ; result := <
       (!(env', (e1, e2, exp_lhs, exp_rhs, stmts_lhs, stmts_rhs)) ; merge)
    <+ (!(env', (exp_lhs, exp_rhs, stmts_lhs, stmts_rhs)) ; merge)
    >
   
  binexp-to-js-stmts-with-null-check(get, merge) = (id, get ; ?(e1,e2)) ; binexp-to-js-stmts(!(e1,e2), binexp-null-check(merge|e1, e2))   
  
  exp-to-js-stmts = get-binexp(binexp-to-js-stmts-with-null-check)
  
  get-binexp(merge) = merge(?Addition(e1, e2)           ; !(e1, e2), js-add) 
  
  get-binexp(merge) = merge(?Subtraction(e1, e2)        ; !(e1 ,e2), merge-subtract)
  merge-subtract: (e1, e2, exp_lhs, exp_rhs) -> js-exp |[
    (exp_lhs.getTime() - exp_rhs.getTime()) / 1000
  ]|
    where
      (Datetime(), Datetime()) := <(get-type2, get-type2)> (e1, e2)
  merge-subtract = js-sub
  
  get-binexp(merge) = merge(?Multiplication(e1, e2)     ; !(e1, e2), js-mul)
  get-binexp(merge) = merge(?Division(e1, e2)           ; !(e1, e2), js-div)
  get-binexp(merge) = merge(?FloorDivision(e1, e2)      ; !(e1, e2), merge-floor-div)
  merge-floor-div : (exp_lhs, exp_rhs) -> js-exp|[
    parseInt(exp_lhs / exp_rhs)
  ]|
  get-binexp(merge) = merge(?Modulo(e1, e2)             ; !(e1, e2), js-modulo)
  
  //comparison operators
  get-binexp(merge) = merge(?LessThan(e1, e2)           ; !(e1, e2), merge-compare(js-lt))
  get-binexp(merge) = merge(?LessThanEqual(e1, e2)      ; !(e1, e2), merge-compare(js-lte))
  get-binexp(merge) = merge(?GreaterThan(e1, e2)        ; !(e1, e2), merge-compare(js-gt))
  get-binexp(merge) = merge(?GreaterThanEqual(e1, e2)   ; !(e1, e2), merge-compare(js-gte))
  get-binexp(merge) = merge(?Equal(e1, e2)              ; !(e1, e2), merge-compare(js-eq))
  get-binexp(merge) = merge(?Inequal(e1, e2)            ; !(e1, e2), merge-compare(js-neq))
  
  merge-compare(compare) : (e1, e2, exp_lhs, exp_rhs) -> <compare> (exp_lhs', exp_rhs')
    where
      (Datetime(), Datetime()) := <(get-type2, get-type2)> (e1, e2)
    with
      exp_lhs' := js-exp |[exp_lhs.getTime()]|
    ; exp_rhs' := js-exp |[exp_rhs.getTime()]|
  merge-compare(compare) = compare
  
  //Logical operators
  
  
  exp-to-js-stmts = ?(_, And(e1, e2)) ; binexp-merge(!(e1,e2), merge-and)
  merge-and: (env, (exp_lhs, exp_rhs, stmts_lhs, stmts_rhs)) -> result
    with
      (env', x_result) := <fresh-variable> env
    ; stmts :=
      js-stmt* |[
      var x_result;
      stmts_lhs
      if(exp_lhs === false){
        x_result = false;
      } else {
        stmts_rhs
        x_result = exp_rhs;
      }
    ]|
    ; result := (env', (<js-var> x_result, stmts))
  
  
  exp-to-js-stmts = ?(_, Or(e1, e2)) ; binexp-merge(!(e1,e2), merge-or)
  merge-or: (env, (exp_lhs, exp_rhs, stmts_lhs, stmts_rhs)) -> result
    with
      (env', x_result) := <fresh-variable> env
    ; stmts := js-stmt* |[
      var x_result;
      stmts_lhs
      if(exp_lhs === true){
        x_result = true;
      } else {
        stmts_rhs
        x_result = exp_rhs;
      }
    ]|
    ; result := (env', (<js-var> x_result, stmts))
  
  
  exp-to-js-stmts = ?(_, Difference(e1,e2)) ; binexp-merge(!(e1,e2), merge-difference)
  
  merge-difference: (env, (e1, e2, exp_lhs, exp_rhs)) -> result
    with
      exp_result := <switch <(get-multiplicity, get-multiplicity)> (e1, e2)
        case (upper-one, upper-one):
          !js-exp |[exp_lhs == exp_rhs ? null : exp_lhs]|
        case (upper-one, upper-many):
          !js-exp |[_.includes(exp_rhs, exp_lhs) ? null : exp_lhs]|
        case (upper-many, upper-one):
          !js-exp |[exp_rhs == null ? exp_lhs : _.without(exp_lhs, exp_rhs)]|
        case (upper-many, upper-many):
          !js-exp |[_.difference(exp_lhs, exp_rhs)]|
      end>
    ; result := (env, (exp_result, []))
  
  
  exp-to-js-stmts = ?(_, ChoiceLeft(e1, e2)) ; binexp-merge(!(e1,e2), merge-choiceleft)
  
  merge-choiceleft: (env, (e_lhs, e_rhs, exp_lhs, exp_rhs, stmts_lhs, stmts_rhs)) -> result
    with
      (env', x_result) := <fresh-variable> env
    ; exp_nonempty := <check-nonempty> (<get-multiplicity> e_lhs, exp_lhs)
    ; stmts := js-stmt* |[
      stmts_lhs
      if(exp_nonempty){
        x_result = exp_lhs;
      } else{
        stmts_rhs
        x_result = exp_rhs;
      }
    ]|
    ; result := (env', (<js-var> x_result, stmts))
  
  exp-to-js-stmts = ?(env, Merge(e1, e2)) ; binexp-to-js-stmts(!(e1, e2), merge-merge)
  
  merge-merge : (e1, e2, exp_lhs, exp_rhs) -> js-exp |[
    exp_lhs2.concat(exp_rhs2)
  ]|
    with
      exp_lhs2 := <exp-to-list> (e1, exp_lhs) 
    ; exp_rhs2 := <exp-to-list> (e2, exp_rhs)
  
  exp-to-list: (e, exp_e) -> exp_result
    with
      exp_empty := <exp-empty> ZeroOrMore()
    ; switch <get-multiplicity> e
        case lower-one; upper-one:
          exp_result := js-exp |[[exp_e]]|
        case lower-zero ; upper-one:
          exp_result := js-exp |[exp_e == null ? exp_empty : [exp_e]]|
        otherwise:
          exp_result := exp_e
      end
  
  // Unary expressions
  
  unexp-to-js-stmts(get, merge) : (env, e) -> result
    where
      e_inner := <get> e
    with
      (env', [
        (exp_inner, stmts_inner),
        x_result
      ]) := <thread-environment(exp-to-js-stmts(|e_inner), fresh-variable)> env
    ; (env'', exp_merge) := <merge ; (?(_,_) <+ !(env', <id>))> (env', e_inner, exp_inner) 
    ; stmts_result := js-stmt* |[
      stmts_inner
      var x_result = exp_merge;
    ]|
    ; exp_result := <js-var> x_result
    ; result := (env'', (exp_result, stmts_result))
  
  unexp-null-check(merge) : params @ (_, e, exp_e) -> exp_result 
    where
      exp_merge := <merge> params
    with  
     switch <get-multiplicity> e
      case lower-one:
        exp_result := exp_merge
      otherwise:
        exp_result := js-exp |[exp_e !== null ? exp_merge : null]|
    end
  
  unexp-to-js-stmts-with-null-check(get, merge) = unexp-to-js-stmts(get, unexp-null-check(merge))
  
  exp-to-js-stmts = get-unexp(unexp-to-js-stmts-with-null-check)
  
  get-unexp(merge) = merge(?Not(<id>), ?(_, _, <js-not>))
  get-unexp(merge) = merge(?Cast(<id>, t), merge-cast(|t))
  
  merge-cast(|t2) : (_, e, exp_e) -> exp_result
    with
      t1 := <get-type2> e
    ; exp_result := <switch !(t1,t2)
      case ?(Float(), Int())        : !js-exp |[parseInt(exp_e)]|
      case ?(Datetime(), String())  : <js-function-call> ("dateToString", [exp_e])
      otherwise                     : !exp_e
    end>
  
  exp-to-js-stmts : (env, If(c, t, f)) -> result
    with
      (env', [
        (exp_c, stmts_c),
        (exp_t, stmts_t),
        (exp_f, stmts_f),
        x_result
      ]) := <thread-environment(
        exp-to-js-stmts(|c),
        exp-to-js-stmts(|t),
        exp-to-js-stmts(|f),
        fresh-variable
      )> env
    ; stmts_result := js-stmt* |[
      var x_result;
      stmts_c
      if(exp_c){
        stmts_t
        x_result = exp_t; 
      } else{
        stmts_f
        x_result = exp_f;
      }
    ]|
    ; exp_result := <js-var> x_result
    ; result := (env', (exp_result, stmts_result))
  
  //Functions
  
  exp-to-js-stmts: (env, Function(name, args)) -> result
    with
      (env', (exps_exp_args, stmts_stmts_args)) := <exp-fold2> (env, args)
    ; exp_result := <js-function-call> (name, exps_exp_args)
    ; stmts_args := <concat> stmts_stmts_args
    ; result := (env', (exp_result, stmts_args))
    
    
  js-function-call: (x_fn, exp_args*) -> js-exp |[functions.x_fn(exp_args*)]|

  exp-to-js-stmts: (env, Filter(e_source, var, e_body)) -> result
    with
      (env', [
        (exp_source, stmts_source),
        x_var,
        (exp_body, stmts_body),
        x_result,
        x_loop
      ]) := <thread-environment(
        exp-to-js-stmts(|e_source),
        push-scope,
        store-variable(|var),
        exp-to-js-stmts(|e_body),
        pop-scope,
        fresh-variable,
        fresh-variable
      )> env
    ; stmts_result := js-stmt* |[
      stmts_source
      var x_result = [];
      for(var x_loop = 0 ; x_loop < exp_source.length ; x_loop++){
        var x_var = exp_source[x_loop];
        stmts_body
        if(exp_body){
          x_result.push(x_var);
        }
      }
    ]|
    ; exp_result := <js-var> x_result
    ; result := (env', (exp_result, stmts_result))
    
  exp-to-js-stmts: (env, OrderBy(e_source, var, e_body)) -> result
    with
      (env', [
        (exp_source, stmts_source),
        x_arg1,
        x_arg2,
        x_var,
        (exp_body, stmts_body),
        x_result
      ]) := <thread-environment(
        exp-to-js-stmts(|e_source),
        fresh-variable,
        fresh-variable,
        push-scope,
        store-variable(|var),
        exp-to-js-stmts(|e_body),
        pop-scope,
        fresh-variable
      )> env
    ; stmts_result := js-stmt* |[
      stmts_source
      var x_result = exp_source.slice().sort(function(x_arg1, x_arg2){
        var x_var = x_arg1;
        stmts_body
        x_arg1 = exp_body;
        x_var = x_arg2;
        stmts_body
        x_arg2 = exp_body;
        return x_arg1 - x_arg2;
      });
    ]|
    ; exp_result := <js-var> x_result
    ; result := (env', (exp_result, stmts_result))
    
  exp-to-js-stmts: (env, Find(e_source, var, e_body)) -> result
    with
      (env', [
        (exp_source, stmts_source),
        x_var,
        (exp_body, stmts_body),
        x_loop,
        x_result
      ]) := <thread-environment(
        exp-to-js-stmts(|e_source),
        push-scope,
        store-variable(|var),
        exp-to-js-stmts(|e_body),
        pop-scope,
        fresh-variable,
        fresh-variable
      )> env
    ; stmts_result := js-stmt* |[
      stmts_source
      var x_result = null;
      for(var x_loop = 0 ; x_loop < exp_source.length && x_result === null ; x_loop++){
        var x_var = exp_source[x_loop];
        stmts_body
        if(exp_body){
          x_result = x_var;
        }
      }
    ]|
    ; exp_result := <js-var> x_result
    ; result := (env', (exp_result, stmts_result))
    
  //References
  
  
  exp-to-js-stmts = ?(env, Ref(x)) ; !(env, (<get-variable ; js-var> (env, x), []))
  
  exp-to-js-stmts: (env, m@MemberAccess(e, field)) -> result
    with
      (env', (exp_e, stmts_e)) := <exp-to-js-stmts> (env, e)
    ; m_inner := <get-multiplicity> e
    ; m_outer := <get-multiplicity> m    
    ; x_getter := <getter-name> field
    ; switch !(m_inner, m_outer)
      case (upper-many, upper-many):
        (env'', [x_result, x_inner, x_innerElem, x_loop1, x_loop2]) := <thread-environment(fresh-variable, fresh-variable, fresh-variable, fresh-variable, fresh-variable)> env'
      ; stmts_result := js-stmts |[
        stmts_e
        var x_result = [];
        var x_inner = exp_e;
        for(var x_loop1 = 0 ; x_loop1 < x_inner.length ; x_loop1++){
          var x_innerElem = x_inner[x_loop1].x_getter();
          for(var x_loop2 = 0 ; x_loop2 < x_innerElem.length ; x_loop2++){
            x_result.push(x_innerElem[x_loop2]);
          }
        }
      ]|
      ; result := (env'', (<js-var> x_result, stmts_result))
      otherwise:
        result := (env', (js-exp |[
          exp_e.x_getter()
        ]|, []))
    end
    
  
    
  exp-to-js-stmts: (env, Ref(field)) -> (env, (exp_result, [])) 
    with
      x_getter := <getter-name> field
    ; exp_result := js-exp |[this.x_getter()]|
    
   
  exp-to-js-stmts = ?(env, Ref(x)) ; !(env, (<get-variable ; js-var> (env, x), []))

  //Helpers
  
  check-nonempty = where((upper-one, ?exp_e)) ; !js-exp |[exp_e !== null]|
  check-nonempty = where((upper-many, ?exp_e)) ; !js-exp |[exp_e.length !== 0]|
  
  exp-fold = env-fold(do-exp-fold)
  
  do-exp-fold : ((env, acc), e) -> result
    with
      (env', exp_e, stmts_e) := <exp-to-js-stmts> (env, e)
    ; result := (env', [(exp_e, stmts_e) | acc])
  
  exp-fold2 = env-fold(do-exp-fold2| ([], []))  
  do-exp-fold2 : ((env, (exps, stmts)), e) -> result
    with
      (env', (exp_e, stmts_e)) := <exp-to-js-stmts> (env, e)
    ; result := (env', ([exp_e | exps], [stmts_e | stmts]))
  
  exp-empty = upper-one ; exp-empty-one
  exp-empty = upper-many ; exp-empty-many
  exp-empty-one  = !js-exp |[null]|
  exp-empty-many = !js-exp |[EMPTY_ARRAY]|
  
  